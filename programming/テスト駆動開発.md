[テスト駆動開発](https://www.amazon.co.jp/dp/B077D2L69C/ref=dp-kindle-redirect?_encoding=UTF8&btkr=1)の要約

イントロダクション
---

「動作する綺麗なコード」がテスト駆動開発のゴール

#### メリット

  - 開発が予測可能になる
  - コードが伝えようとしていることをがわかる
  - 品質が担保できる
  - チームメイトが信頼してくれる
  - 書いていて気持ちがいい

####  方法

- 自動化がされたテストが失敗した時のみ開発する
- 作業の流れ
    1. レッド:  動作しない、コンパイルも通らないテストを1つ書く
    1. グリーン: そのテストを迅速に動作させる。通すためなら何をしてもいい
    1. リファクタリング:  テストを通すために発生した重複を除去する
- 詳細な作業の流れ
    1. テストを1つ書く
    1. 全てのテストを走らせ、新しいテストの失敗を確認
    1.  小さな変更を行う
    1.  全てのテストを走らせ、全て成功することを確認する
    1. リファクタリングを行なって重複を除去する

1部 他国通貨
---
他国通貨計算のプログラムを例にし、テストをコードより先に書き、設計する方法を学ぶ

-  1章: 仮実装: まずテストを書いて、テストを通すためならベタがきのコードでもとりあえず動かせ
-  2章: 明白な実装: 仮実装(ベタ書き)と明白な実装(リファクタ)を揺れ動かしながら開発する
-  3章: 三角測量を行う: コードを一般化する時には二つのテストケースを用意する
``` java
private int plus(int augend, int addend) {
    return 4;
}

@Test
public void testSum() {
    // 1つのテストだとこれはOKなのでplus()が間違っていることがわかない
    assertEquals(4, plus(3, 1))
    // 2つだとこれはNGなのでplus()が間違っていることがわかる、リファクタが終われば冗長なテストなので消す
    assertEquals(7, plus(3, 4))
}
```
- 4章  意図を語るテスト         : アサーションメソッドに渡す値は意図がわかりやすいものにする(new Instanceするなど)
- 5章  原則をあえて破るとき     : コピペしてもいいからまずはテストを通せ
- 6章  テスト不足に気がついたら : あればよかったなーというテストはリファクタの前に追加して書くべき
- 7章  疑念をテストに翻訳する   : 疑問に思うことも先にテストしてテストを通すコードを書け
- 8章  実装を隠す               : 不要なコードがあると気がついたらテストを変える前にそのコード実装自体を消せるように変更加える(テストが通った状態で)
- 9章  歩幅の調整               : 修正の単位に決まりはないので、大きいと思ったら小さくし、小さいと思ったら大きくして良い
- 10章 テストに聞いてみる       : リファクタ中わかんなくなったらとりあえずテストを実行しろ、それでもわからないなら追加でテストを書け
- 11章 不要になったら消す       : 不要なコードを削除、テストもいらなくなったらテストコードも削除
- 12章 設計とメタファー         : 設計を変更する際はそのメタファーにあったようなテストコードに書き直す
- 13章 実装を導くテスト : こう実装すれば良いよを先にテストに書いてその通り実装する（難しくない？）
- 14章 学習用テストと回帰テスト: 今まで書いてたテストで失敗したら、原因の最小単位を試すテストを書く。設計もれと思おう。
- 15章 テスト任せとコンパイラ任せ: リファクタ時にはテストの前にコンパイラ任せにすると実装を導けるよね（セヤナ）
- 16章 将来の読み手を考えたテスト:  自分だけが触るコード！であれば結合テストくらいでいいのでは？
  > TDDをやっていると、テストコードとプロダクトコードの行数は、同じくらいになる。つまりこれまでの2倍コードをかけるようになるか、半分のコード量で同じだけの機能をかけるようになるかしかないと、TDDのメリットを得られ無いということだ。
  > 実装だけではなく、デバッグやインテグレーション、人への説明などに要する時間も考慮することを忘れずに。
- 17章 : 他国通貨の全体振り返り
  - TDDで作ったテストは以下のテストの代替にはならない
    - パフォーマンステスト
    - 負荷テスト
    - ユーザビリティテスト
  - カバレッジを上げる方法はテストコードをたくさんかくだけじゃなく、ロジックをシンプルにするという方法もある


2部 xUnit
---
複雑なロジック、リフレクションや例外のテスト方法を学ぶ
自分でテスティングフレームワークを作りながら上記を学ぼうという内容（何をしてるのか最初わからなかった…）
なお、TDDの理念にのっとり上記のテスティングフレームワークももちろんテストを先に書きながら進めます
写経: https://github.com/hyakt/test_driven_development

- 18章 xUnit(自作のテストフレームワーク)へ向かう小さな一歩:  テストメソッドを呼び出せるように実装
- 19章 前準備: setUp() メソッドを実装し、できるだけ早く、他のテストの影響を受けないようした
- 20章 後片付け: tearDown() メソッドを実装し、リソースの開放を行えるようにした
- 21章 数え上げ: テストの実行結果を「5 run, 2 failed」などわかるように実装
- 22章 失敗の扱い: 例外が発生した場合 failed + 1 してあげるのを実装
- 23章 スイートにまとめる: テストをまとめて実行できるクラスを追加
- 24章 xUnitの全体振り返り
  - 熟達: xUnitは様々な言語で実装されているが、それを自分で実装することで1から理解できる
  - 探索: xUnitを実装することで、プログラミング言語自体の必要機能が網羅できる

3部 テスト駆動開発のパターン
---
どのようなテストを各課の判断に関するパターンを学ぶ
TDDのベストヒットパターン集
